# Fastfile for iOS App Store Deployment (API-key only)

default_platform(:ios)

# ---- Helpers ----
def asc_api_key
  app_store_connect_api_key(
    key_id:     ENV['ASC_KEY_ID']     || ENV['APP_STORE_CONNECT_API_KEY_ID'],
    issuer_id:  ENV['ASC_ISSUER_ID']  || ENV['APP_STORE_CONNECT_API_ISSUER_ID'],
    key_filepath: ENV['ASC_KEY_PATH'] || ENV['APP_STORE_CONNECT_API_KEY_PATH']
  )
end

def run_match(readonly: true)
  # Determine keychain based on environment (matching Matchfile logic)
  if ENV["MATCH_KEYCHAIN_NAME"] && !ENV["MATCH_KEYCHAIN_NAME"].empty?
    keychain_name = ENV["MATCH_KEYCHAIN_NAME"]
  elsif ENV["CI"] || ENV["GITHUB_ACTIONS"]
    keychain_name = "ci-keys.keychain-db"
  else
    keychain_name = "login.keychain-db"
  end

  keychain_path = keychain_name.include?("/") ? keychain_name : File.join(ENV['HOME'], "Library/Keychains/#{keychain_name}")

  # For CI keychain, ensure it exists and is unlocked
  if keychain_name == "ci-keys.keychain-db" && ENV['CI_KEYCHAIN_PWD']
    # Create keychain if it doesn't exist
    begin
      sh("security create-keychain -p '#{ENV['CI_KEYCHAIN_PWD']}' '#{keychain_path}'")
    rescue => e
      UI.important("Keychain may already exist: #{e.message}")
    end
    
    # Unlock and configure keychain
    sh("security unlock-keychain -p '#{ENV['CI_KEYCHAIN_PWD']}' '#{keychain_path}'")
    sh("security set-keychain-settings -t 3600 -l '#{keychain_path}'")
    sh("security list-keychains -d user -s '#{keychain_path}' login.keychain")
  elsif keychain_name == "login.keychain-db" && ENV['MAC_LOGIN_PWD'] && !ENV['MAC_LOGIN_PWD'].empty?
    sh("security unlock-keychain -p '#{ENV['MAC_LOGIN_PWD']}' '#{keychain_path}'")
  end

  match(
    type: "appstore",
    readonly: readonly,
    app_identifier: ["com.getmaximumfreedomandfitness.getmaximumfitiosapp"],
    team_id: ENV['APPLE_TEAM_ID'],
    keychain_name: keychain_name,
    keychain_password: (keychain_name == "ci-keys.keychain-db" ? ENV['CI_KEYCHAIN_PWD'] : nil),
    storage_mode: "git",
    git_url: ENV['MATCH_GIT_URL'],
    git_basic_authorization: ENV['MATCH_GIT_BASIC_AUTHORIZATION'],
    api_key: asc_api_key
  )

  UI.success("âœ… Certificates & profiles synced using #{keychain_name}")
end

platform :ios do
  desc "Sync certificates and provisioning profiles (readonly)"
  lane :sync_certificates do
    run_match(readonly: true)
  end

  desc "Regenerate provisioning profiles with capabilities"
  lane :regenerate_profiles do
    UI.important("ğŸ”„ Force regenerating provisioning profiles to include app capabilities...")
    run_match(readonly: false)
    UI.success("âœ… Provisioning profiles regenerated with HealthKit and Sign in with Apple capabilities")
  end

  desc "Build the app for App Store"
  lane :build_app_store do
    # Install certificates using Match (but skip provisioning profiles)
    UI.important("ğŸ”„ Installing certificates...")
    run_match(readonly: false, type: "appstore", app_identifier: "com.getmaximumfreedomandfitness.getmaximumfitiosapp")

    # Install the local provisioning profile
    local_profile_path = File.join(Dir.pwd, "match_AppStore_comgetmaximumfreedomandfitnessgetmaximumfitiosapp-new.mobileprovision")
    
    if File.exist?(local_profile_path)
      UI.message("ï¿½ Installing local provisioning profile: #{local_profile_path}")
      
      # Install the provisioning profile
      install_provisioning_profile(path: local_profile_path)
      
      # Get the profile name by reading the profile
      profile_content = File.read(local_profile_path)
      # Extract profile name from the mobileprovision file
      profile_name = "match AppStore com.getmaximumfreedomandfitness.getmaximumfitiosapp"
      
      UI.success("âœ… Installed local provisioning profile: #{profile_name}")
    else
      UI.user_error!("âŒ Local provisioning profile not found at: #{local_profile_path}")
    end

    # Verify certificates are available in the correct keychain
    keychain_name = ENV["MATCH_KEYCHAIN_NAME"] && !ENV["MATCH_KEYCHAIN_NAME"].empty? ? ENV["MATCH_KEYCHAIN_NAME"] : 
                   (ENV["CI"] || ENV["GITHUB_ACTIONS"]) ? "ci-keys.keychain-db" : "login.keychain-db"
    keychain_path = keychain_name.include?("/") ? keychain_name : File.join(ENV['HOME'], "Library/Keychains/#{keychain_name}")
    
    begin
      result = sh("security find-identity -v -p codesigning '#{keychain_path}'", log: false)
      UI.message("ğŸ“‹ Available signing identities (#{keychain_name}):\n#{result}")
      
      # Specifically check for Distribution certificate
      if result.include?("Apple Distribution")
        UI.success("âœ… Found Apple Distribution certificate for App Store builds")
      else
        UI.error("âŒ Missing Apple Distribution certificate - only found: #{result.strip}")
      end
    rescue => e
      UI.error("Failed to list signing identities: #{e.message}")
    end

    # Unique build number (timestamp)
    increment_build_number(build_number: Time.now.to_i.to_s)

    UI.message("ğŸ“± Using local provisioning profile: #{profile_name}")

    gym(
      scheme: "GetMaximumFit",
      configuration: "Release",
      export_method: "app-store",
      codesigning_identity: "Apple Distribution",
      export_options: {
        provisioningProfiles: {
          "com.getmaximumfreedomandfitness.getmaximumfitiosapp" => profile_name
        }
      },
      output_directory: "./",
      output_name: "GetMaximumFit.ipa"
    )
  end

  desc "Upload to TestFlight"
  lane :upload_testflight do
    build_app_store
    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )
    slack(message: "ğŸš€ New build uploaded to TestFlight!", success: true) if ENV["SLACK_URL"]
  end

  desc "Build and upload beta to TestFlight"
  lane :beta do
    UI.important("ğŸ”„ Ensuring provisioning profiles are up to date for beta...")
    run_match(readonly: false)

    increment_build_number(build_number: Time.now.to_i.to_s)

    # Get the provisioning profile that Match just installed
    profile_name = ENV["sigh_com.getmaximumfreedomandfitness.getmaximumfitiosapp_appstore_profile-name"]
    UI.message("ğŸ“± Using provisioning profile: #{profile_name}")

    gym(
      scheme: "GetMaximumFit",
      configuration: "Release",
      export_method: "app-store",
      codesigning_identity: "Apple Distribution",
      export_options: {
        provisioningProfiles: {
          "com.getmaximumfreedomandfitness.getmaximumfitiosapp" => profile_name
        }
      },
      output_directory: "./",
      output_name: "GetMaximumFit.ipa"
    )

    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )

    UI.success("ğŸ‰ Beta build uploaded to TestFlight!")
  end

  desc "Deploy to App Store (via TestFlight upload)"
  lane :deploy_app_store do
    build_app_store
    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )
    UI.success("ğŸ‰ Production build uploaded to TestFlight!")
  end

  desc "Bootstrap on a machine: setup keychain + pull certs"
  lane :ci_bootstrap do
    # This will use the appropriate keychain based on environment
    sync_certificates
  end

  error do |lane, exception|
    slack(message: "âŒ Build failed in lane #{lane}: #{exception.message}", success: false) if ENV["SLACK_URL"]
  end
end