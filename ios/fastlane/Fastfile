# Fastfile for iOS App Store Deployment (API-key only)

default_platform(:ios)

# ---- Helpers ----
def asc_api_key
  app_store_connect_api_key(
    key_id:     ENV['ASC_KEY_ID']     || ENV['APP_STORE_CONNECT_API_KEY_ID'],
    issuer_id:  ENV['ASC_ISSUER_ID']  || ENV['APP_STORE_CONNECT_API_ISSUER_ID'],
    key_filepath: ENV['ASC_KEY_PATH'] || ENV['APP_STORE_CONNECT_API_KEY_PATH']
  )
end

def run_match(readonly: true)
  # Use local login keychain (no custom CI keychain)
  login_keychain = File.join(ENV['HOME'], "Library/Keychains/login.keychain-db")

  # Optionally unlock the login keychain if you provide MAC_LOGIN_PWD
  if ENV['MAC_LOGIN_PWD'] && !ENV['MAC_LOGIN_PWD'].empty?
    sh("security unlock-keychain -p '#{ENV['MAC_LOGIN_PWD']}' '#{login_keychain}'")
  end

  match(
    type: "appstore",
    readonly: readonly,
    app_identifier: ["com.getmaximumfreedomandfitness.getmaximumfitiosapp"],
    team_id: ENV['APPLE_TEAM_ID'],
    keychain_name: "login.keychain-db",   # <- explicit login keychain
    # keychain_password: NOT NEEDED for login keychain
    storage_mode: "git",
    git_url: ENV['MATCH_GIT_URL'],
    git_basic_authorization: ENV['MATCH_GIT_BASIC_AUTHORIZATION'],
    api_key: asc_api_key
  )

  UI.success("‚úÖ Certificates & profiles synced using login.keychain-db")
end

platform :ios do
  desc "Sync certificates and provisioning profiles (readonly)"
  lane :sync_certificates do
    match(
      type: "appstore",
      readonly: true,
      keychain_name: "login.keychain-db" # explicit, or omit to use default
    )
  end

  desc "Regenerate provisioning profiles with capabilities"
  lane :regenerate_profiles do
    UI.important("üîÑ Force regenerating provisioning profiles to include app capabilities...")
    run_match(readonly: false)
    UI.success("‚úÖ Provisioning profiles regenerated with HealthKit and Sign in with Apple capabilities")
  end

  desc "Build the app for App Store"
  lane :build_app_store do
    # Ensure provisioning profiles are current
    UI.important("üîÑ Ensuring provisioning profiles are up to date...")
    run_match(readonly: false)

    # Verify certificates are available in login keychain
    begin
      result = sh("security find-identity -v -p codesigning ~/Library/Keychains/login.keychain-db", log: false)
      UI.message("üìã Available signing identities (login):\n#{result}")
    rescue => e
      UI.error("Failed to list signing identities: #{e.message}")
    end

    # Unique build number (timestamp)
    increment_build_number(build_number: Time.now.to_i.to_s)

    gym(
      scheme: "GetMaximumFit",
      configuration: "Release",
      export_method: "app-store",
      codesigning_identity: "Apple Distribution",
      output_directory: "./",
      output_name: "GetMaximumFit.ipa"
    )
  end

  desc "Upload to TestFlight"
  lane :upload_testflight do
    build_app_store
    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )
    slack(message: "üöÄ New build uploaded to TestFlight!", success: true) if ENV["SLACK_URL"]
  end

  desc "Build and upload beta to TestFlight"
  lane :beta do
    UI.important("üîÑ Ensuring provisioning profiles are up to date for beta...")
    run_match(readonly: false)

    increment_build_number(build_number: Time.now.to_i.to_s)

    gym(
      scheme: "GetMaximumFit",
      configuration: "Release",
      export_method: "app-store",
      codesigning_identity: "Apple Distribution",
      output_directory: "./",
      output_name: "GetMaximumFit.ipa"
    )

    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )

    UI.success("üéâ Beta build uploaded to TestFlight!")
  end

  desc "Deploy to App Store (via TestFlight upload)"
  lane :deploy_app_store do
    build_app_store
    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )
    UI.success("üéâ Production build uploaded to TestFlight!")
  end

  # Renamed to avoid clashing with built-in 'setup_ci' action
  desc "Bootstrap on a machine: unlock login keychain (optional) + pull certs"
  lane :ci_bootstrap do
    # Optionally unlock login keychain if password provided
    if ENV['MAC_LOGIN_PWD'] && !ENV['MAC_LOGIN_PWD'].empty?
      sh("security unlock-keychain -p '#{ENV['MAC_LOGIN_PWD']}' ~/Library/Keychains/login.keychain-db")
    end
    run_match(readonly: true)
  end

  error do |lane, exception|
    slack(message: "‚ùå Build failed in lane #{lane}: #{exception.message}", success: false) if ENV["SLACK_URL"]
  end
end