# Fastfile for iOS App Store Deployment (API-key only)

default_platform(:ios)

# ---- Helpers ----
def asc_api_key
  app_store_connect_api_key(
    key_id:     ENV['ASC_KEY_ID']     || ENV['APP_STORE_CONNECT_API_KEY_ID'],
    issuer_id:  ENV['ASC_ISSUER_ID']  || ENV['APP_STORE_CONNECT_API_ISSUER_ID'],
    key_filepath: ENV['ASC_KEY_PATH'] || ENV['APP_STORE_CONNECT_API_KEY_PATH']
  )
end

def run_match(readonly: true)
  # Ensure keychain exists and is unlocked before running match
  keychain_name = ENV['MATCH_KEYCHAIN_NAME'] || "ci-keys.keychain"
  
  # Unlock keychain before match runs
  begin
    sh("security unlock-keychain -p '#{ENV['CI_KEYCHAIN_PWD']}' '#{keychain_name}'")
  rescue => e
    UI.important("Keychain unlock failed, keychain may not exist yet: #{e.message}")
  end
  
  match(
    type: "appstore",
    readonly: readonly,
    app_identifier: ["com.getmaximumfreedomandfitness.getmaximumfitiosapp"],
    team_id: ENV['APPLE_TEAM_ID'],
    keychain_name: keychain_name,
    keychain_password: ENV['CI_KEYCHAIN_PWD'],
    storage_mode: "git",
    git_url: ENV['MATCH_GIT_URL'],
    git_basic_authorization: ENV['MATCH_GIT_BASIC_AUTHORIZATION'],
    api_key: asc_api_key
  )
  
  # Ensure keychain remains unlocked and accessible for code signing
  sh("security unlock-keychain -p '#{ENV['CI_KEYCHAIN_PWD']}' '#{keychain_name}'")
  sh("security set-keychain-settings -t 3600 -l '#{keychain_name}'")
  
  # Set the keychain search list to include our CI keychain
  sh("security list-keychains -d user -s '#{keychain_name}' login.keychain")
  
  UI.success("âœ… Keychain setup complete and certificates installed")
end

platform :ios do
  desc "Sync certificates and provisioning profiles (readonly)"
  lane :sync_certificates do
    match(
      type: "appstore",
      readonly: true,
      keychain_name: "login.keychain-db" # or omit entirely to use default
    )
  end

  desc "Regenerate provisioning profiles with capabilities"
  lane :regenerate_profiles do
    UI.important("ğŸ”„ Force regenerating provisioning profiles to include app capabilities...")
    run_match(readonly: false)
    UI.success("âœ… Provisioning profiles regenerated with HealthKit and Sign in with Apple capabilities")
  end

  desc "Build the app for App Store"
  lane :build_app_store do
    # Force regeneration of provisioning profiles to ensure capabilities are included
    UI.important("ğŸ”„ Regenerating provisioning profiles with required capabilities...")
    run_match(readonly: false)

    # Verify certificates are available before building
    keychain_name = ENV['MATCH_KEYCHAIN_NAME'] || "ci-keys.keychain"
    begin
      result = sh("security find-identity -v -p codesigning '#{keychain_name}'", log: false)
      UI.message("ğŸ“‹ Available signing identities:\n#{result}")
    rescue => e
      UI.error("Failed to list signing identities: #{e.message}")
    end

    # Unique build number (timestamp)
    increment_build_number(build_number: Time.now.to_i.to_s)

    gym(
      scheme: "GetMaximumFit",
      configuration: "Release",
      export_method: "app-store",
      codesigning_identity: "Apple Distribution",
      output_directory: "./",
      output_name: "GetMaximumFit.ipa"
    )
  end

  desc "Upload to TestFlight"
  lane :upload_testflight do
    build_app_store
    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )
    slack(message: "ğŸš€ New build uploaded to TestFlight!", success: true) if ENV["SLACK_URL"]
  end

  desc "Build and upload beta to TestFlight"
  lane :beta do
    # Force regeneration of provisioning profiles to ensure capabilities are included
    UI.important("ğŸ”„ Regenerating provisioning profiles with required capabilities...")
    run_match(readonly: false)

    increment_build_number(build_number: Time.now.to_i.to_s)

    gym(
      scheme: "GetMaximumFit",
      configuration: "Release",
      export_method: "app-store",
      codesigning_identity: "Apple Distribution",
      output_directory: "./",
      output_name: "GetMaximumFit.ipa"
    )

    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )

    UI.success("ğŸ‰ Beta build uploaded to TestFlight!")
  end

  desc "Deploy to App Store (via TestFlight upload)"
  lane :deploy_app_store do
    build_app_store
    upload_to_testflight(
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      skip_submission: true
    )
    UI.success("ğŸ‰ Production build uploaded to TestFlight!")
  end

  desc "Setup CI keychain + pull certs"
  lane :ci_setup do
    create_keychain(
      name: ENV['MATCH_KEYCHAIN_NAME'] || "ci-keys.keychain",
      password: ENV['CI_KEYCHAIN_PWD'],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )
    run_match(readonly: true)
  end

  error do |lane, exception|
    slack(message: "âŒ Build failed in lane #{lane}: #{exception.message}", success: false) if ENV["SLACK_URL"]
  end
end