name: iOS CI Self-Hosted

# Updated: Fixed token newline stripping in Match authentication
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Deployment Type'
        required: true
        default: 'testflight'
        type: choice
        options:
        - testflight
        - production

env:
  # Firebase Configuration
  EXPO_PUBLIC_FIREBASE_API_KEY: ${{ secrets.EXPO_PUBLIC_FIREBASE_API_KEY }}
  EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN: ${{ secrets.EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN }}
  EXPO_PUBLIC_FIREBASE_DATABASE_URL: ${{ secrets.EXPO_PUBLIC_FIREBASE_DATABASE_URL }}
  EXPO_PUBLIC_FIREBASE_PROJECT_ID: ${{ secrets.EXPO_PUBLIC_FIREBASE_PROJECT_ID }}
  EXPO_PUBLIC_FIREBASE_STORAGE_BUCKET: ${{ secrets.EXPO_PUBLIC_FIREBASE_STORAGE_BUCKET }}
  EXPO_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.EXPO_PUBLIC_FIREBASE_MESSAGING_SENDER_ID }}
  EXPO_PUBLIC_FIREBASE_APP_ID: ${{ secrets.EXPO_PUBLIC_FIREBASE_APP_ID }}
  
  # Google OAuth Configuration
  EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID: ${{ secrets.EXPO_PUBLIC_GOOGLE_IOS_CLIENT_ID }}
  EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID: ${{ secrets.EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID }}
  
  # API Configuration
  EXPO_PUBLIC_API_BASE_URL: ${{ secrets.EXPO_PUBLIC_API_BASE_URL }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  EXPO_PUBLIC_OPENAI_API_KEY: ${{ secrets.EXPO_PUBLIC_OPENAI_API_KEY }}
  
  # RevenueCat Configuration
  EXPO_PUBLIC_REVENUECAT_IOS_API_KEY: ${{ secrets.EXPO_PUBLIC_REVENUECAT_IOS_API_KEY }}

  
  # Expo Configuration
  EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

jobs:
  # Job 1: Code Quality and Testing
  quality-check:
    name: Code Quality Check
    runs-on: [self-hosted, macOS, ARM64, xcode-15]
    timeout-minutes: 15
    steps:
      - name: ðŸ§¹ Clean up CI keychains
        run: |
          echo "Cleaning up any existing CI keychains..."
          
          # Restore login keychain as default
          security default-keychain -s login.keychain
          
          # Remove any CI keychains from search list
          security list-keychains -s login.keychain
          
          # Delete any existing CI keychains
          security delete-keychain ci-keys.keychain || true
          for keychain in $(security list-keychains | grep -i ci-keys | tr -d '"' | xargs); do
            security delete-keychain "$keychain" || true
            echo "Deleted keychain: $keychain"
          done
          
          echo "CI keychain cleanup completed"

      - name: ðŸ§¹ Clean up existing processes
        run: |
          echo "Cleaning up any existing TypeScript or Node processes..."
          # Kill any existing TypeScript server processes
          pkill -f "tsserver" || true
          pkill -f "typescript" || true
          # Clean up any node processes that might be hanging
          pkill -f "node.*tsc" || true
          # Clean up any git processes that might be hanging
          pkill -f "git fetch" || true
          pkill -f "git clone" || true
          
          # Check runner workspace
          echo "Current working directory: $(pwd)"
          echo "Workspace contents:"
          ls -la ${{ github.workspace }} || echo "Workspace doesn't exist yet"
          
          # Clean up any stale git locks
          find ${{ github.workspace }} -name "*.lock" -delete 2>/dev/null || true
          
          echo "Process cleanup completed"

      - name: ðŸŒ Test network connectivity
        run: |
          echo "Testing network connectivity..."
          ping -c 3 github.com || echo "Ping failed"
          curl -I https://github.com || echo "Curl failed"
          echo "Network test completed"

      - name: ðŸ” Setup Git Authentication
        run: |
          echo "Setting up git authentication for webcache account..."
          echo "Current git config:"
          git config --global --list | grep -E "(user\.|credential\.|url\.)" || echo "No relevant git config found"
          
          # Completely reset git configuration
          git config --global --unset-all credential.helper || true
          git config --global --unset-all url.https://github.com/.insteadOf || true
          git config --global --remove-section url "https://github.com/" || true
          rm -f ~/.git-credentials || true
          rm -f ~/.gitconfig || true
          
          # Set up fresh git configuration
          git config --global user.name "webcache"
          git config --global user.email "actions@github.com"
          git config --global init.defaultBranch main
          
          # Configure git to use token authentication for this session
          git config --global credential.helper "store --file ~/.git-credentials-ci"
          echo "https://webcache:${{ secrets.GITHUB_TOKEN }}@github.com" > ~/.git-credentials-ci
          
          echo "Testing git access to repository..."
          git ls-remote https://github.com/${{ github.repository }}.git > /dev/null && echo "âœ… Repository access successful" || echo "âŒ Repository access failed"
          
          echo "Git authentication configured with fresh credentials"

      - name: ðŸ— Setup repo
        uses: actions/checkout@v4
        timeout-minutes: 5
        with:
          clean: true
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}
        env:
          GIT_TRACE: 1
          GIT_CURL_VERBOSE: 1
          
      - name: ðŸ”„ Fallback git setup (if needed)
        if: failure()
        run: |
          echo "Standard checkout failed, trying manual git setup..."
          cd ${{ github.workspace }} || true
          
          # Configure git with authentication
          git config --global http.postBuffer 1048576000
          git config --global http.maxRequestBuffer 100M
          git config --global core.compression 0
          git config --global user.name "webcache"
          git config --global user.email "actions@github.com"
          
          # Use GitHub token for authentication
          git clone --depth 1 --single-branch --branch main https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git . || {
            echo "Clone failed, trying reset..."
            git reset --hard origin/main || true
          }

      - name: ðŸ— Verify Node (using local installation)
        run: |
          echo "Using local Node.js installation on Mac mini..."
          echo "Node version: $(node --version)"
          echo "NPM version: $(npm --version)"
          echo "Node path: $(which node)"
          echo "NPM path: $(which npm)"

      - name: ðŸ“¦ Check dependency cache
        id: cache-deps
        run: |
          # Check if node_modules exists and package-lock.json hasn't changed
          if [ -d "node_modules" ] && [ -f "package-lock.json" ]; then
            LOCK_HASH=$(shasum -a 256 package-lock.json | cut -d' ' -f1)
            CACHE_FILE=".npm-cache-hash"
            
            if [ -f "$CACHE_FILE" ] && [ "$(cat $CACHE_FILE)" = "$LOCK_HASH" ]; then
              echo "cache-hit=true" >> $GITHUB_OUTPUT
              echo "Dependencies are up to date, skipping npm install"
            else
              echo "cache-hit=false" >> $GITHUB_OUTPUT
              echo "$LOCK_HASH" > "$CACHE_FILE"
              echo "Dependencies need to be updated"
            fi
          else
            echo "cache-hit=false" >> $GITHUB_OUTPUT
            echo "node_modules not found, will install dependencies"
          fi

      - name: ðŸ§¹ Clean package manager conflicts
        run: |
          if [ -f "yarn.lock" ]; then
            echo "Removing yarn.lock to prevent conflicts with npm"
            rm yarn.lock
          fi

      - name: ðŸ“¦ Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: |
          echo "Installing npm dependencies..."
          echo "Node version: $(node --version)"
          echo "NPM version: $(npm --version)"
          npm ci --verbose
          echo "Dependencies installed successfully!"

      - name: âœ… Dependencies ready
        run: |
          if [ "${{ steps.cache-deps.outputs.cache-hit }}" = "true" ]; then
            echo "âœ… Using cached dependencies"
          else
            echo "âœ… Fresh dependencies installed"
          fi

      - name: ðŸ” TypeScript check
        timeout-minutes: 5
        run: |
          echo "Starting TypeScript compilation check..."
          echo "Project files count: $(find . -name "*.ts" -o -name "*.tsx" | wc -l)"
          
          # Clear any TypeScript caches
          rm -rf .tsbuildinfo node_modules/.cache || true
          
          echo "Running: npx tsc --noEmit"
          npx tsc --noEmit --pretty --incremental false
          echo "TypeScript check completed successfully!"

      - name: âœ… Code quality check completed
        run: echo "âœ… TypeScript check passed - code quality verified"

      - name: ðŸ§¹ Cleanup Git Credentials
        if: always()
        run: |
          echo "Cleaning up temporary git credentials..."
          rm -f ~/.git-credentials-ci || true
          git config --global --unset credential.helper || true
          echo "Git credentials cleanup completed"

  # Job 2: Build iOS App
  build-ios:
    name: Build iOS App
    runs-on: [self-hosted, macOS, ARM64, xcode-15]
    timeout-minutes: 60
    needs: quality-check
    steps:
      - name: ðŸ§¹ Clean up CI keychains
        run: |
          echo "Cleaning up any existing CI keychains..."
          
          # Restore login keychain as default
          security default-keychain -s login.keychain
          
          # Remove any CI keychains from search list
          security list-keychains -s login.keychain
          
          # Delete any existing CI keychains
          security delete-keychain ci-keys.keychain || true
          for keychain in $(security list-keychains | grep -i ci-keys | tr -d '"' | xargs); do
            security delete-keychain "$keychain" || true
            echo "Deleted keychain: $keychain"
          done
          
          echo "CI keychain cleanup completed"

      - name: ðŸ§¹ Clean up existing processes
        run: |
          echo "Cleaning up any existing processes..."
          pkill -f "tsserver" || true
          pkill -f "typescript" || true
          pkill -f "node.*tsc" || true
          echo "Process cleanup completed"

      - name: ðŸ” Setup Git Authentication
        run: |
          echo "Setting up git authentication for webcache account..."
          
          # Completely reset git configuration
          git config --global --unset-all credential.helper || true
          git config --global --unset-all url.https://github.com/.insteadOf || true
          git config --global --remove-section url "https://github.com/" || true
          rm -f ~/.git-credentials || true
          
          # Set up fresh git configuration
          git config --global user.name "webcache"
          git config --global user.email "actions@github.com"
          
          # Configure git to use token authentication for this session
          git config --global credential.helper "store --file ~/.git-credentials-ci"
          echo "https://webcache:${{ secrets.GITHUB_TOKEN }}@github.com" > ~/.git-credentials-ci
          
          echo "Git authentication configured"

      - name: ðŸ— Setup repo
        uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ— Verify Node (using local installation)
        run: |
          echo "Using local Node.js installation on Mac mini..."
          echo "Node version: $(node --version)"
          echo "NPM version: $(npm --version)"
          echo "Node path: $(which node)"
          echo "NPM path: $(which npm)"

      - name: ðŸ“¦ Check JavaScript dependency cache
        id: cache-js-deps
        run: |
          # Check if node_modules exists and package-lock.json hasn't changed
          if [ -d "node_modules" ] && [ -f "package-lock.json" ]; then
            LOCK_HASH=$(shasum -a 256 package-lock.json | cut -d' ' -f1)
            CACHE_FILE=".npm-cache-hash"
            
            if [ -f "$CACHE_FILE" ] && [ "$(cat $CACHE_FILE)" = "$LOCK_HASH" ]; then
              echo "cache-hit=true" >> $GITHUB_OUTPUT
              echo "JavaScript dependencies are up to date"
            else
              echo "cache-hit=false" >> $GITHUB_OUTPUT
              echo "$LOCK_HASH" > "$CACHE_FILE"
              echo "JavaScript dependencies need update"
            fi
          else
            echo "cache-hit=false" >> $GITHUB_OUTPUT
            echo "node_modules not found"
          fi

      - name: ðŸ“¦ Install JavaScript dependencies
        if: steps.cache-js-deps.outputs.cache-hit != 'true'
        run: |
          echo "Installing JavaScript dependencies..."
          npm ci
          echo "JavaScript dependencies installed!"

      - name: âœ… JavaScript dependencies ready
        run: |
          if [ "${{ steps.cache-js-deps.outputs.cache-hit }}" = "true" ]; then
            echo "âœ… Using cached JavaScript dependencies"
          else
            echo "âœ… Fresh JavaScript dependencies installed"
          fi

      - name: âœï¸ Write GoogleService-Info.plist
        run: |
          echo "$IOS_GOOGLE_SERVICE_PLIST_B64" | base64 --decode > ios/GetMaximumFit/GoogleService-Info.plist
        env:
          IOS_GOOGLE_SERVICE_PLIST_B64: ${{ secrets.IOS_GOOGLE_SERVICE_PLIST_B64 }}

      - name: ðŸ”‘ Setup App Store Connect API Key
        run: |
          mkdir -p ios/fastlane/keys
          echo "$APP_STORE_CONNECT_API_KEY_CONTENT" | base64 --decode > ios/fastlane/keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8
        env:
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}

      - name:  iOS deps
        working-directory: ios
        run: |
          gem install bundler --no-document
          bundle install --jobs 4
          bundle exec pod install --repo-update

      - name: ðŸ”‘ Setup CI Keychain
        run: |
          # Delete keychain if it exists to start fresh
          security delete-keychain ci-keys.keychain || true
          
          # Create new keychain with a unique name to avoid conflicts
          KEYCHAIN_NAME="ci-keys-$(date +%s).keychain"
          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
          
          # Create new keychain
          security create-keychain -p "$CI_KEYCHAIN_PWD" "$KEYCHAIN_NAME"
          
          # Set keychain settings (shorter timeout for CI)
          security set-keychain-settings -t 1800 -l "$KEYCHAIN_NAME"
          
          # Add to keychain search list (but keep login.keychain as primary)
          security list-keychains -s "$KEYCHAIN_NAME" login.keychain
          
          # Set as default keychain only for this session
          security default-keychain -s "$KEYCHAIN_NAME"
          
          # Unlock keychain
          security unlock-keychain -p "$CI_KEYCHAIN_PWD" "$KEYCHAIN_NAME"
          
          echo "âœ… CI keychain $KEYCHAIN_NAME created and configured"
        env:
          CI_KEYCHAIN_PWD: ${{ secrets.CI_KEYCHAIN_PWD }}

      - name: ðŸ§ª Test Match Configuration
        working-directory: ios
        run: |
          echo "ðŸ” Testing Match password and git access..."
          
          # Clear all Fastlane/Match caches and temporary files
          echo "ðŸ§¹ Clearing Fastlane and Match caches..."
          rm -rf ~/.fastlane || true
          rm -rf /var/folders/*/T/d*-*-* || true
          rm -rf /tmp/fastlane* || true
          rm -rf /tmp/match* || true
          rm -rf ~/.match_version_check || true
          
          # Clear any existing git credential cache
          git config --global --unset credential.helper || true
          rm -f ~/.git-credentials* || true
          
          # Configure git authentication using the authorization token
          echo "Setting up git authentication for Match repository..."
          AUTH_STRING=$(echo "$MATCH_GIT_BASIC_AUTHORIZATION" | base64 --decode)
          USERNAME=$(echo "$AUTH_STRING" | cut -d: -f1)
          TOKEN=$(echo "$AUTH_STRING" | cut -d: -f2 | tr -d '\n\r')  # Strip any newlines from token
          
          echo "GitHub Username: $USERNAME"
          echo "Match Git URL: $MATCH_GIT_URL"
          echo "Expected GitHub username should be: webcache"
          echo "ðŸ” Secret format check - should end with 'bw==': $(echo "$MATCH_GIT_BASIC_AUTHORIZATION" | tail -c 5)"
          echo "ðŸ” Token length after cleanup: ${#TOKEN}"
          
          # Check if the username matches the expected GitHub account
          if [ "$USERNAME" != "webcache" ]; then
            echo "âš ï¸  Warning: GitHub username in MATCH_GIT_BASIC_AUTHORIZATION is '$USERNAME' but should be 'webcache'"
            echo "Updating to use webcache username..."
            USERNAME="webcache"
          fi
          
          # Test git access to the Match repository first
          echo "Testing git repository access to Match repo..."
          echo "ðŸ” Match Git URL: $MATCH_GIT_URL"
          
          # Ensure the URL has .git suffix
          if [[ "$MATCH_GIT_URL" != *.git ]]; then
            echo "âš ï¸  Warning: MATCH_GIT_URL doesn't end with .git - this might cause issues"
            echo "Expected format: https://github.com/webcache/githubactionsstore.git"
          fi
          
          # Test with explicit authentication using the cleaned token
          echo "Testing git authentication methods..."
          
          # Method 1: Test with token in URL
          AUTHENTICATED_URL=$(echo "$MATCH_GIT_URL" | sed 's|https://|https://webcache:'$TOKEN'@|')
          echo "Method 1: Testing with token in URL..."
          git ls-remote "$AUTHENTICATED_URL" > /dev/null 2>&1 && {
            echo "âœ… Method 1 successful: Token in URL works"
            GIT_AUTH_METHOD="url"
          } || {
            echo "âŒ Method 1 failed: Token in URL"
            
            # Method 2: Test with credential helper
            echo "Method 2: Testing with credential helper..."
            git config --global credential.helper store
            echo "https://webcache:$TOKEN@github.com" > ~/.git-credentials
            
            git ls-remote "$MATCH_GIT_URL" > /dev/null 2>&1 && {
              echo "âœ… Method 2 successful: Credential helper works"
              GIT_AUTH_METHOD="credential"
            } || {
              echo "âŒ Method 2 failed: Credential helper"
              
              # Method 3: Test with git config url rewrite
              echo "Method 3: Testing with git URL rewrite..."
              git config --global url."https://webcache:$TOKEN@github.com/".insteadOf "https://github.com/"
              
              git ls-remote "$MATCH_GIT_URL" > /dev/null 2>&1 && {
                echo "âœ… Method 3 successful: URL rewrite works"
                GIT_AUTH_METHOD="rewrite"
              } || {
                echo "âŒ All git authentication methods failed"
                echo "Repository URL: ${AUTHENTICATED_URL//$TOKEN/***}"
                echo "Checking repository existence via API..."
                API_RESPONSE=$(curl -s -H "Authorization: token $TOKEN" "https://api.github.com/repos/webcache/githubactionsstore")
                echo "API Response: $(echo "$API_RESPONSE" | jq -r '.message // "Repository accessible via API"')"
                
                # Check token permissions
                echo "Checking token permissions..."
                USER_RESPONSE=$(curl -s -H "Authorization: token $TOKEN" "https://api.github.com/user")
                echo "Token user: $(echo "$USER_RESPONSE" | jq -r '.login // "Token validation failed"')"
                
                # Check token scopes
                echo "Checking token scopes..."
                curl -s -I -H "Authorization: token $TOKEN" "https://api.github.com/user" | grep -i "x-oauth-scopes" || echo "No scope information available"
                
                echo "âš ï¸  Git authentication failed but API works - this suggests token scope issues"
                echo "ðŸ“ Common cause: Token needs 'repo' scope for private repository git operations"
                echo "ðŸ”§ Will attempt to proceed with Match using alternative git URL method..."
                
                # Set a fallback method and continue (don't exit)
                GIT_AUTH_METHOD="url"
                echo "Proceeding with token-in-URL method for Match execution"
              }
            }
          }
          
          # Configure git credentials for this session using the working method
          case "$GIT_AUTH_METHOD" in
            "url")
              echo "Using token in URL method for git authentication"
              # No additional config needed, will use token in URL directly
              ;;
            "credential")
              echo "Using credential helper method for git authentication"
              git config --global credential.helper store
              echo "https://webcache:$TOKEN@github.com" > ~/.git-credentials
              ;;
            "rewrite")
              echo "Using URL rewrite method for git authentication"
              git config --global url."https://webcache:$TOKEN@github.com/".insteadOf "https://github.com/"
              ;;
          esac
          
          echo "âœ… Git authentication configured successfully using $GIT_AUTH_METHOD method"
          
          # Test Match password - create a new MATCH_GIT_BASIC_AUTHORIZATION with correct username
          CORRECT_AUTH=$(echo -n "webcache:$TOKEN" | base64)
          
          echo "Testing Match password with correct GitHub credentials..."
          echo "ðŸ” Using corrected auth format - should end with 'bw==': $(echo "$CORRECT_AUTH" | tail -c 5)"
          echo "ðŸ” Corrected auth length: ${#CORRECT_AUTH}"
          echo "ðŸ” Match password length: ${#MATCH_PASSWORD}"
          
          # Check if password length seems reasonable
          if [ ${#MATCH_PASSWORD} -lt 12 ]; then
            echo "âš ï¸  Warning: Match password is only ${#MATCH_PASSWORD} characters - consider using a longer password"
          fi
          
          # Force Match to re-clone the repository by using a fresh temporary directory
          TEMP_MATCH_DIR="/tmp/match-test-$(date +%s)"
          echo "ðŸ”§ Testing Match with certificate creation enabled..."
          echo "Using App Store Connect API for authentication (no Apple ID required)..."
          echo "ðŸ”‘ App Store Connect API Key ID: $ASC_KEY_ID"
          echo "ðŸ”‘ App Store Connect Issuer ID: $ASC_ISSUER_ID"
          echo "ðŸ”‘ API Key Path: ./fastlane/keys/AuthKey_$ASC_KEY_ID.p8"
          
          # Verify API key file exists
          if [ ! -f "./fastlane/keys/AuthKey_$ASC_KEY_ID.p8" ]; then
            echo "âŒ API Key file not found: ./fastlane/keys/AuthKey_$ASC_KEY_ID.p8"
            echo "Current directory: $(pwd)"
            echo "Contents of current directory:"
            ls -la
            echo "Contents of fastlane directory:"
            ls -la fastlane/ || echo "Fastlane directory doesn't exist"
            echo "Contents of fastlane/keys directory:"
            ls -la fastlane/keys/ || echo "Keys directory doesn't exist"
            exit 1
          fi
          
          echo "âœ… API key file verified"
          
          # Prepare Match execution with special git URL handling if needed
          echo "ðŸ”§ Preparing Match execution with git authentication method: $GIT_AUTH_METHOD"
          
          # If git tests failed, try using git URL with embedded token for Match
          if [ "$GIT_AUTH_METHOD" = "url" ]; then
            # Create a temporary git URL with embedded authentication
            MATCH_GIT_URL_WITH_AUTH=$(echo "$MATCH_GIT_URL" | sed 's|https://|https://webcache:'$TOKEN'@|')
            echo "Using git URL with embedded token for Match"
            
            # Temporarily modify the Matchfile to use authenticated URL
            cp fastlane/Matchfile fastlane/Matchfile.backup
            sed 's|git_url("https://github.com/webcache/githubactionsstore.git")|git_url("'$MATCH_GIT_URL_WITH_AUTH'")|' fastlane/Matchfile.backup > fastlane/Matchfile
          fi
          
          # Execute Match with proper environment variables
          env MATCH_GIT_BASIC_AUTHORIZATION="$CORRECT_AUTH" \
              TMPDIR="$TEMP_MATCH_DIR" \
              ASC_KEY_ID="$ASC_KEY_ID" \
              ASC_ISSUER_ID="$ASC_ISSUER_ID" \
              ASC_KEY_PATH="./fastlane/keys/AuthKey_$ASC_KEY_ID.p8" \
              SPACESHIP_CONNECT_API_KEY_ID="$ASC_KEY_ID" \
              SPACESHIP_CONNECT_API_ISSUER_ID="$ASC_ISSUER_ID" \
              SPACESHIP_CONNECT_API_KEY_FILEPATH="./fastlane/keys/AuthKey_$ASC_KEY_ID.p8" \
              FASTLANE_USER="" \
              FASTLANE_PASSWORD="" \
              FASTLANE_DONT_STORE_PASSWORD=1 \
              FASTLANE_SKIP_UPDATE_CHECK=1 \
              DELIVER_USERNAME="" \
              DELIVER_PASSWORD="" \
              MATCH_SKIP_CONFIRMATION=1 \
              MATCH_READONLY=false \
              APP_STORE_CONNECT_API_KEY_ID="$ASC_KEY_ID" \
              APP_STORE_CONNECT_API_ISSUER_ID="$ASC_ISSUER_ID" \
              APP_STORE_CONNECT_API_KEY_FILEPATH="./fastlane/keys/AuthKey_$ASC_KEY_ID.p8" \
              FASTLANE_SESSION="" \
              FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD="" \
              bundle exec fastlane match appstore --force --verbose --skip_confirmation || {
            echo "âŒ Match test failed - checking details..."
            echo "Git URL: $MATCH_GIT_URL"
            echo "Match password length: ${#MATCH_PASSWORD}"
            echo "GitHub Username: webcache"
            echo "Checking if token has repository access..."
            curl -H "Authorization: token $TOKEN" "https://api.github.com/repos/webcache/githubactionsstore" || echo "Repository access check failed"
            
            # Restore original Matchfile if we modified it
            if [ -f "fastlane/Matchfile.backup" ]; then
              mv fastlane/Matchfile.backup fastlane/Matchfile
            fi
            
            # Clean up temp directory
            rm -rf "$TEMP_MATCH_DIR" || true
            exit 1
          }
          
          # Restore original Matchfile if we modified it
          if [ -f "fastlane/Matchfile.backup" ]; then
            mv fastlane/Matchfile.backup fastlane/Matchfile
          fi
          
          # Clean up temp directory and credentials based on method used
          rm -rf "$TEMP_MATCH_DIR" || true
          
          case "${GIT_AUTH_METHOD:-credential}" in
            "credential")
              rm -f ~/.git-credentials
              git config --global --unset credential.helper || true
              ;;
            "rewrite")
              git config --global --unset url."https://webcache:$TOKEN@github.com/".insteadOf || true
              ;;
            "url")
              # No cleanup needed for URL method
              ;;
          esac
          
          echo "âœ… Match configuration test passed!"
        env:
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          ASC_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}

      - name: ðŸŽ Fastlane Beta
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deployment_type == 'testflight')
        working-directory: ios
        env:
          ASC_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          ASC_KEY_PATH: "./fastlane/keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8"
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          CI_KEYCHAIN_PWD: ${{ secrets.CI_KEYCHAIN_PWD }}
          GIT_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
        run: |
          # Set up git authentication for Match using webcache username
          AUTH_STRING=$(echo "$MATCH_GIT_BASIC_AUTHORIZATION" | base64 --decode)
          USERNAME=$(echo "$AUTH_STRING" | cut -d: -f1)
          TOKEN=$(echo "$AUTH_STRING" | cut -d: -f2 | tr -d '\n\r')  # Strip any newlines from token
          
          # Ensure we use webcache username for GitHub operations
          if [ "$USERNAME" != "webcache" ]; then
            echo "Correcting GitHub username from '$USERNAME' to 'webcache'"
            USERNAME="webcache"
          fi
          
          # Use credential helper method for git authentication (most reliable)
          echo "Setting up git authentication for Fastlane..."
          git config --global credential.helper store
          echo "https://$USERNAME:$TOKEN@github.com" > ~/.git-credentials
          
          # Create correct MATCH_GIT_BASIC_AUTHORIZATION for Fastlane - with clean token
          export MATCH_GIT_BASIC_AUTHORIZATION=$(echo -n "webcache:$TOKEN" | base64)
          
          # Run Fastlane
          bundle exec fastlane beta
          
          # Clean up
          rm -f ~/.git-credentials
          git config --global --unset credential.helper || true

      - name: ðŸŽ Fastlane Production
        if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deployment_type == 'production')) && !(github.event_name == 'workflow_dispatch' && github.event.inputs.deployment_type == 'testflight')
        working-directory: ios
        env:
          ASC_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          ASC_KEY_PATH: "./fastlane/keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8"
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
          CI_KEYCHAIN_PWD: ${{ secrets.CI_KEYCHAIN_PWD }}
          GIT_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
        run: |
          # Set up git authentication for Match using webcache username
          AUTH_STRING=$(echo "$MATCH_GIT_BASIC_AUTHORIZATION" | base64 --decode)
          USERNAME=$(echo "$AUTH_STRING" | cut -d: -f1)
          TOKEN=$(echo "$AUTH_STRING" | cut -d: -f2 | tr -d '\n\r')  # Strip any newlines from token
          
          # Ensure we use webcache username for GitHub operations
          if [ "$USERNAME" != "webcache" ]; then
            echo "Correcting GitHub username from '$USERNAME' to 'webcache'"
            USERNAME="webcache"
          fi
          
          # Use credential helper method for git authentication (most reliable)
          echo "Setting up git authentication for Fastlane..."
          git config --global credential.helper store
          echo "https://$USERNAME:$TOKEN@github.com" > ~/.git-credentials
          
          # Create correct MATCH_GIT_BASIC_AUTHORIZATION for Fastlane - with clean token
          export MATCH_GIT_BASIC_AUTHORIZATION=$(echo -n "webcache:$TOKEN" | base64)
          
          # Run Fastlane
          bundle exec fastlane deploy_app_store
          
          # Clean up
          rm -f ~/.git-credentials
          git config --global --unset credential.helper || true

      - name: ðŸ§¹ Cleanup CI Keychain
        if: always()
        run: |
          echo "Cleaning up CI keychain..."
          
          # Restore login keychain as default
          security default-keychain -s login.keychain
          
          # Remove CI keychain from search list
          security list-keychains -s login.keychain
          
          # Delete the CI keychain if it exists
          if [ -n "${KEYCHAIN_NAME:-}" ]; then
            security delete-keychain "$KEYCHAIN_NAME" || true
            echo "âœ… Deleted CI keychain: $KEYCHAIN_NAME"
          else
            # Fallback: delete any ci-keys keychains
            security delete-keychain ci-keys.keychain || true
            security delete-keychain ci-keys-*.keychain || true
            echo "âœ… Cleaned up any existing ci-keys keychains"
          fi
          
          echo "Keychain cleanup completed"

  # Job 3: Notify on completion
  notify:
    name: Notify Completion
    runs-on: [self-hosted, macOS, ARM64, xcode-15]
    needs: build-ios
    if: always() && github.ref == 'refs/heads/main'
    steps:
      - name: ðŸ“¢ Deployment Summary
        run: |
          echo "ðŸŽ‰ iOS deployment completed!"
          echo "ðŸ“± iOS Build: ${{ needs.build-ios.result }}"